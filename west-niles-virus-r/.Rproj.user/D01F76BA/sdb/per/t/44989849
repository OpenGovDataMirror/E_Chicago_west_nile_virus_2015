{
    "contents" : "suppressWarnings(library(\"data.table\"))\nsuppressWarnings(library(\"compiler\"))\n\nenableJIT(3) \nsetCompilerOptions(suppressUndefined = T)\noptions(stringsAsFactors = FALSE)\noptions(max.print = 1000)\noptions(scipen=999)\n\npath.wd <- getwd()\nSys.setenv(\"R_LOCAL_CACHE\"=\"../data/output-r/.R_Cache\")\n\nsuppressWarnings(library(\"SOAR\"))\nsuppressWarnings(library(\"SparseM\"))\nsuppressWarnings(library(\"Matrix\"))\nsuppressWarnings(library(\"geosphere\"))\nObjects()\n\nall.noexport <- c(\"fn_auc\", \"fn_opt_auc\")\n\n#############################################################\n# tic toc\n#############################################################\ntic <- function(gcFirst = TRUE, type=c(\"elapsed\", \"user.self\", \"sys.self\")) {\n  type <- match.arg(type)\n  assign(\".type\", type, envir=baseenv())\n  if(gcFirst) gc(FALSE)\n  tic <- proc.time()[type]         \n  assign(\".tic\", tic, envir=baseenv())\n  invisible(tic)\n}\n\ntoc <- function() {\n  type <- get(\".type\", envir=baseenv())\n  toc <- proc.time()[type]\n  tic <- get(\".tic\", envir=baseenv())\n  print(toc - tic)\n  invisible(toc)\n}\n\n##############################################################\n## Registers parallel workers\n##############################################################\nfn.register.wk <- function(n.proc = NULL) {\n  if (file.exists(\"../data/cluster.csv\")) {\n    cluster.conf <- read.csv(fn.in.file(\"cluster.csv\"), \n                             stringsAsFactors = F,\n                             comment.char = \"#\")\n    n.proc <- NULL\n    for (i in 1:nrow(cluster.conf)) {\n      n.proc <- c(n.proc, \n                  rep(cluster.conf$host[i], \n                      cluster.conf$cores[i]))\n    }\n  }\n  if (is.null(n.proc)) {\n    n.proc = as.integer(Sys.getenv(\"NUMBER_OF_PROCESSORS\"))\n    if (is.na(n.proc)) {\n      library(parallel)\n      n.proc <-detectCores()\n    }\n    n.proc <- max(c(floor(n.proc*0.5), 1))\n  }\n  workers <- mget(\".pworkers\", envir=baseenv(), ifnotfound=list(NULL));\n  if (!exists(\".pworkers\", envir=baseenv()) || length(workers$.pworkers) == 0) {\n    \n    library(doSNOW)\n    library(foreach)\n    workers<-suppressWarnings(makeSOCKcluster(n.proc));\n    suppressWarnings(registerDoSNOW(workers))\n    clusterSetupRNG(workers, seed=5478557)\n    assign(\".pworkers\", workers, envir=baseenv());\n    \n    tic()\n    cat(\"Workers start time: \", format(Sys.time(), \n                                       format = \"%Y-%m-%d %H:%M:%S\"), \"\\n\")\n  }\n  invisible(workers);\n}\n\n##############################################################\n## Kill parallel workers\n##############################################################\nfn.kill.wk <- function() {\n  library(\"doSNOW\")\n  library(\"foreach\")\n  workers <- mget(\".pworkers\", envir=baseenv(), ifnotfound=list(NULL));\n  if (exists(\".pworkers\", envir=baseenv()) && length(workers$.pworkers) != 0) {\n    stopCluster(workers$.pworkers);\n    assign(\".pworkers\", NULL, envir=baseenv());\n    cat(\"Workers finish time: \", format(Sys.time(), \n                                        format = \"%Y-%m-%d %H:%M:%S\"), \"\\n\")\n    toc()\n  }\n  invisible(workers);\n}\n\n##############################################################\n## init worker setting work dir and doing path redirect\n##############################################################\nfn.init.worker <- function(log = NULL, add.date = F) {\n  setwd(path.wd)\n  \n  if (!is.null(log)) {\n    date.str <- format(Sys.time(), format = \"%Y-%m-%d_%H-%M-%S\")\n    \n    if (add.date) {\n      output.file <- fn.log.file(paste(log, \"_\",date.str,\n                                       \".log\", sep=\"\"))\n    } else {\n      output.file <- fn.log.file(paste(log,\".log\", sep=\"\"))\n    }\n    \n    dir.create(dirname(output.file), showWarnings = F, recursive = T)\n    output.file <- file(output.file, open = \"wt\")\n    sink(output.file)\n    sink(output.file, type = \"message\")\n    \n    cat(\"Start:\", date.str, \"\\n\")\n  }\n  \n  tic()\n}\n\n##############################################################\n## clean worker resources\n##############################################################\nfn.clean.worker <- function() {\n  gc()\n  \n  try(toc(), silent=T)\n  suppressWarnings(sink())\n  suppressWarnings(sink(type = \"message\"))\n}\n\n##############################################################\n## wait clean\n##############################################################\nfn.gc.wait <- function() {\n  invisible(gc())\n  Sys.sleep(1)\n  invisible(gc())\n  Sys.sleep(1)\n  invisible(gc())\n}\n\n#############################################################\n# log file path\n#############################################################\nfn.base.dir <- function(extra) {\n  paste0(path.wd, \"/../data/\", extra)\n}\n\n#############################################################\n# log file path\n#############################################################\nfn.log.file <- function(name) {\n  fn.base.dir(paste0(\"log/\", name))\n}\n\n#############################################################\n# input file path\n#############################################################\nfn.in.file <- function(name) {\n  fn.base.dir(paste0(\"input/\", name))\n}\n\n#############################################################\n# R output file path\n#############################################################\nfn.out.file <- function(name) {\n  fn.base.dir(paste0(\"output-r/\", name))\n}\n\n#############################################################\n# python output file path\n#############################################################\nfn.py.file <- function(name) {\n  fn.base.dir(paste0(\"output-py/\", name))\n}\n\n#############################################################\n# rgf output file path\n#############################################################\nfn.rgf.file <- function(name) {\n  fn.base.dir(paste0(\"output-rgf/\", name))\n}\n\n\n#############################################################\n# submission file path\n#############################################################\nfn.submission.file <- function(name, suffix=\".csv\") {\n  fn.base.dir(paste0(\"submission/\", name, suffix))\n}\n\n#############################################################\n# data file path\n#############################################################\nfn.data.file <- function(name) {\n  fn.out.file(name)\n}\n\n#############################################################\n# save data file\n#############################################################\nfn.save.data <- function(dt.name, envir = parent.frame()) {\n  save(list = dt.name, \n       file = fn.data.file(paste0(dt.name, \".RData\")), envir = envir)\n}\n\n#############################################################\n# load saved file\n#############################################################\nfn.load.data <- function(dt.name, envir = parent.frame()) {\n  load(fn.data.file(paste0(dt.name, \".RData\")), envir = envir)\n}\n\n##############################################################\n## auc\n##############################################################\nfn.auc <- function (actual, predicted) \n{\n  library(\"Metrics\")\n  auc(actual=actual, predicted=predicted)\n}\n\n##############################################################\n## print error\n##############################################################\n\n# data.all.pred <- data.all.out[, list(Id)]\n# for (ix in 1:9) data.all.pred[, paste0(\"Pred_\", ix) := 1/9, with=F]\n\nfn.print.err <- function(pred, actual = data.all.out, \n                         pred.col = \"Pred\",\n                         years.avg=F,\n                         do.print=T,\n                         digits=4) {\n  \n  pred.all <- merge(\n    pred[, c(\"Id\", pred.col), with=F], \n    actual[, c(\"Id\", \"WnvPresent\", \"Year\"), with=F], by=\"Id\")\n  \n  pred.all <- pred.all[!is.na(WnvPresent)]\n  df.err <- data.frame(\n    Size=nrow(pred.all),\n    AUC = NA_real_\n  )\n  \n  \n  if (df.err$Size > 0) {\n    if (years.avg) {\n      df.err$AUC <- 0\n      yrs <- sort(unique(pred.all$Year))\n      n <- length(yrs)\n      for (yr in yrs) {\n        auc.cur <- fn.auc(actual = pred.all[Year==yr]$WnvPresent,\n                      predicted = pred.all[Year==yr][[pred.col]])\n        df.err$AUC <- df.err$AUC + auc.cur/n\n        df.err[[paste(yr)]] <- auc.cur\n      }\n    } else {\n      df.err$AUC <- fn.auc(actual = pred.all$WnvPresent,\n                      predicted = pred.all[[pred.col]])\n    }\n  }\n  \n  if (do.print) {\n    print(df.err)\n  }\n  \n  invisible(df.err)\n}\n\n##############################################################\n## cross val folds\n##############################################################\nfn.cv.folds <- function(data.all,  \n                        type=\"sequential\", seed = 34234,\n                        col.id = \"Year\", col.out = \"WnvPresent\") {\n  \n  K = length(unique(data.all[!is.na(WnvPresent)]$Year))\n  ids <- sort(unique(\n    data.all[!is.na(data.all[[col.out]]), col.id, with=F][[1]]))\n  n <- length(ids)\n  library(\"cvTools\")\n  \n  if (!is.null(seed)) {\n    set.seed(seed)\n  }\n  data.cv.folds <- cvFolds(n, K = K, type = type)\n  if (!is.null(seed)) {\n    set.seed(Sys.time())\n  }\n  \n  id.ord <- order(ids)\n  data.cv.folds <- list(\n    n = data.cv.folds$n,\n    K = data.cv.folds$K,\n    which = data.cv.folds$which[data.cv.folds$subsets][id.ord],\n    ids = ids[id.ord],\n    col.id = col.id,\n    col.out = col.out\n  )\n  data.cv.folds\n}\n# debug(fn.cv.folds)\n\n##############################################################\n## cross val selection\n##############################################################\nfn.cv.which <- function(data.all, cv.data, k, type) {\n  if (type == \"tr\") {\n    sel.ids <- cv.data$ids[!cv.data$which %in% k]\n  } else {\n    if (k %in% 1:cv.data$K) {\n      sel.ids <- cv.data$ids[cv.data$which %in% k]\n    } else {\n      sel.ids <- data.all[[cv.data$col.id]][\n        !data.all[[cv.data$col.id]] %in% cv.data$ids]\n    }\n  }\n  ix.sel <- (data.all[[cv.data$col.id]] %in% sel.ids)\n  if (type == \"tr\") {\n    ix.sel <- ix.sel & !is.na(data.all[[cv.data$col.out]])\n  }\n  ix.sel\n}\n\n\n##############################################################\n## write submission file\n##############################################################\nfn.write.submission <- function(data.pred, file.name, \n                                data.test = data.all.out,\n                                fix.species = F) {\n  \n  id.sub <- data.test[is.na(WnvPresent) & Id > 0, Id]\n  data.sub <- data.pred[Id %in% id.sub, c(\"Id\", \"Pred\"), with=F]\n  setnames(data.sub, \"Pred\", \"WnvPresent\")\n  \n#   if (fix.species) {\n#     data.sub <- merge(data.sub, data.all.species, by=\"Id\")\n#     data.sub[\n#       !Species %chin% c(\"CULEX PIPIENS\", \"CULEX PIPIENS/RESTUANS\", \n#                         \"CULEX RESTUANS\", \"UNSPECIFIED CULEX\"), \n#       WnvPresent := 0.0]\n#   }\n  \n  data.sub <- data.sub[order(Id)]\n  if (any(data.sub$WnvPresent > 1)) {\n    data.sub[, WnvPresent := WnvPresent/max(WnvPresent)]\n  }\n  \n  write.csv(\n    data.sub[, list(Id, WnvPresent)],\n    file = xzfile(paste0(fn.submission.file(file.name), \".7z\")), \n    row.names = F, quote = F)\n  invisible(data.sub)\n}\n\n#############################################################\n# print rf importance\n#############################################################\nfn.rf.print.imp <- function(rf) {\n imp <- try(print(data.frame(importance=rf$importance[order(-rf$importance[,1]),]), \n      silent = T))\n}\n\n#############################################################\n# removes overfit from similary table\n#############################################################\nfn.rm.sparse.similarity <- function(data.x, K = 20) {\n  data.all.cv <- data.table(Id = colnames(data.x), Class = -1)\n  data.cv.fold.rm <- fn.cv.folds(data.all.cv, K = 20)\n  for (k.rm in 1:data.cv.fold.rm$K) {\n    rm.idx <- which(fn.cv.which(data.all.cv, data.cv.fold.rm, k.rm, \"test\"))\n    rm.col <- data.all.cv$Id[rm.idx]\n    data.x[rm.idx, rm.col] <- 0\n  }\n  return (data.x)\n}\n\n#############################################################\n# creates data.fold for models\n#############################################################\nfn.create.data.fold <- function(model.name, model.k) {\n  data.fold <- list()\n  data.fold$basename <- model.name\n  data.fold$name <- paste0(data.fold$basename, \"_k_\", model.k)\n  data.fold$logname <- paste(data.fold$basename, data.fold$name, sep=\"/\")\n  data.fold$fname <- fn.out.file(paste0(data.fold$basename, \"/\", \n                                        data.fold$name, \".RData\"))\n  data.fold\n}\n\n\nfn.load.data.fold <- function(model.name, model.k) {\n  load(fn.out.file(paste0(model.name, \"/\", model.name,\n                          \"_k_\", model.k, \".RData\")),\n       envir = parent.frame())\n}\n\n#############################################################\n# saves data from models for later inspection\n#############################################################\nfn.save.data.fold <- function(data.fold) {\n  dir.create(dirname(data.fold$fname), showWarnings = F, recursive = T)\n  save(data.fold, file=data.fold$fname)\n}\n\n##############################################################\n## creates data to tree methods\n##############################################################\nfn.data.2.tree <- function(data.dt, cols.in.dt=colnames(data.dt)) {\n  data.tree.dt <- copy(data.dt)\n  cols.char <- sapply(data.tree.dt[,cols.in.dt,with=F], class)\n  cols.char <- sapply(cols.char, \n                      function(x) any(x %chin% c(\"character\", \"factor\")))\n  cols.char <- names(cols.char)[cols.char]\n  for (col.nam in cols.char) {\n    cat(\"Converting \", col.nam, \" to ordinals ... \\n\")\n    setnames(data.tree.dt, col.nam, \"col_cur\")\n    if (is.factor(data.tree.dt$col_cur)) {\n      dt.unique <- data.table(id_val=levels(data.tree.dt$col_cur))\n      data.tree.dt[, col_cur := as.character(col_cur)]\n    } else {\n      dt.unique <- data.table(id_val=unique(data.tree.dt$col_cur))\n    }\n    dt.unique[, map_val := as.numeric(1:.N)]\n    setkeyv(dt.unique, \"id_val\")\n    data.tree.dt[, col_cur := dt.unique[J(col_cur)]$map_val ]\n    setnames(data.tree.dt, \"col_cur\", col.nam)\n  }\n  \n  for (col.nam in cols.in.dt) {\n    sel.na <- is.na(data.tree.dt[[col.nam]])\n    if (any(sel.na)) {\n      setnames(data.tree.dt, col.nam, \"col_cur\")\n      na.val = min(data.tree.dt$col_cur[!sel.na])-10\n      na.val = min(c(-1000, na.val))\n      cat(\"Setting \", col.nam, \" Nas to value \", na.val, \"... \\n\")\n      data.tree.dt[sel.na, col_cur := na.val ]\n      setnames(data.tree.dt, \"col_cur\", col.nam)\n    }\n  }\n  return (data.tree.dt)\n}\n\n##############################################################\n## load ensemble data\n##############################################################\nfn.load.ens <- function(ens.cols, transf=identity,\n                        print.err = T) {\n  \n  data.ens.pred <- NULL\n  \n  for (pred.nam in ens.cols) {\n    data.cur <- get(pred.nam)\n    data.cur <- transf(data.cur)\n    if (is.null(data.ens.pred)) {\n      data.ens.pred <- data.table(data.cur)\n    } else {\n      data.ens.pred <- merge(data.ens.pred, data.cur, by=\"Id\")\n    }\n    if (print.err) {\n      cat(pred.nam, \":\\n\", sep=\"\")\n      fn.print.err(data.ens.pred)\n    }\n    pred.nam <- gsub(\"^data\\\\.\", \"\", pred.nam)\n    pred.nam <- gsub(\"\\\\.smth$\", \"\", pred.nam)\n    pred.nam <- gsub(\"\\\\.pred$\", \"\", pred.nam)\n    setnames(data.ens.pred, \"Pred\", pred.nam)\n  }\n  data.ens.pred[order(Id)]\n}\n\n##############################################################\n## print correlations\n##############################################################\nfn.ens.cor <- function(data.ens.pred, first.col = NULL, do.print=T) {\n  data.ens.cols <- setdiff(colnames(data.ens.pred), c(\"Id\", \"Year\"))\n  data.ens.cor <- data.frame(t(combn(length(data.ens.cols), 2)))\n  colnames(data.ens.cor) <- c(\"col1\", \"col2\")\n  data.ens.cor$linear_cor <- NA_real_ \n  data.ens.cor$rank_cor <- NA_real_ \n  data.ens.cor$col1 <- data.ens.cols[data.ens.cor$col1]\n  data.ens.cor$col2 <- data.ens.cols[data.ens.cor$col2]\n  if (!is.null(first.col)) {\n    fn.sel.col <- function(cols) {\n      as.logical(apply(sapply(first.col,  function(x) cols %like% x), 1, max))\n    }\n    data.ens.cor <- data.ens.cor[\n      fn.sel.col(data.ens.cor$col1) | fn.sel.col(data.ens.cor$col2),]\n  }\n  for (ix in 1:nrow(data.ens.cor)) {\n    p1 <- data.ens.pred[[data.ens.cor$col1[ix]]]\n    p2 <- data.ens.pred[[data.ens.cor$col2[ix]]]\n    pred.ix <- which((p1 != 0 | p2 != 0) & data.ens.pred$Id > 0)\n    p1 <- p1[pred.ix]\n    p2 <- p2[pred.ix]\n    data.ens.cor$linear_cor[ix] <- cor(p1, p2)\n     data.ens.cor$rank_cor[ix] <- cor(rank(p1), rank(p2))\n  }\n  if (do.print) {\n    print(data.ens.cor)\n  }\n  invisible(data.ens.cor)\n}\n\n##############################################################\n## index filtering\n##############################################################\nfn.filter.ix.species.in <- function(ix, data.all) {\n  ix[data.all$Species[ix] != 'CULEX ZOTHER']\n}\n\nfn.filter.ix.species.out <- function(ix, data.all) {\n  ix[data.all$Species[ix] == 'CULEX ZOTHER']\n}\n\nfn.filter.ix.tr.dups <- function(ix, data.all) {\n  ix[data.all$Id[ix] %in% data.tr.out.max$Id]\n}\n\n##############################################################\n## filter cols by unique values\n##############################################################\nfn.filter.cols <- function(data.all, tr.ix) {\n  cols.vals <- apply(data.all[tr.ix, ], 2, function (x) length(unique(x)))\n  cols.vals <- names(cols.vals)[cols.vals > 1]\n  if (is.data.table(data.all)) {\n    data.all[,cols.vals, with=F]\n  } else {\n    data.all[,cols.vals]\n  }\n}\n\n##############################################################\n## calculates normalized pred average\n##############################################################\nfn.calc.pred.mean <- function(data.pred, rm.zeroes=T) {\n  sel.ix <- rep(T, nrow(data.pred))\n  if (rm.zeroes) {\n    sel.ix <- data.pred$Pred > 0\n  }\n  data.pred.year <- merge(data.pred[sel.ix], data.all.out[, list(Id, Year)], by=\"Id\")\n  data.pred.year <- data.pred.year[\n    ,list(Mean=mean(Pred)),by=\"Year\"][order(Year + (Year %% 2 == 0)*100)]\n  for (ix in 0:1) {\n    data.pred.year[Year %% 2 == ix, Mean := Mean/max(Mean)]\n  }\n  data.pred.year\n}\n\nfn.calc.pred.month.mean <- function(data.pred, rm.zeroes=T) {\n  sel.ix <- rep(T, nrow(data.pred))\n  if (rm.zeroes) {\n    sel.ix <- data.pred$Pred > 0\n  }\n  data.pred.year <- merge(\n    data.pred[sel.ix], \n    fn.add.date.fields(data.all.out)[, list(Id, Year, Month)],\n    by=\"Id\")\n  data.pred.year <- data.pred.year[\n    ,list(Mean=mean(Pred)),by=c(\"Year\", \"Month\")][order(Year + (Year %% 2 == 0)*100, Month)]\n  for (ix in 0:1) {\n    data.pred.year[Year %% 2 == ix, Mean := Mean/max(Mean)]\n  }\n  data.pred.year\n}\n\n##############################################################\n## applies multiplier to predictions\n##############################################################\nfn.apply.mult <- function(data.pred, data.mult=data.mult.01, \n                          rm.zeroes=T) {\n  \n  if (!is.data.table(data.mult)) {\n    for (ix in 1:length(data.mult)) {\n      data.pred = fn.apply.mult(data.pred, data.mult=data.mult[[ix]],\n                                rm.zeroes=rm.zeroes)\n    }\n    return(data.pred)\n  }\n  \n  data.pred.new <- merge(data.pred,\n                         data.all.trap[, list(Id, Year, Month, WeekYear)],\n                         by=\"Id\")\n  sel.ix <- rep(T, nrow(data.pred.new))\n  if (rm.zeroes) {\n    sel.ix <- data.pred.new$Pred > 0\n  }\n  col.by <- intersect(c(\"Year\", \"Month\", \"WeekYear\"), colnames(data.mult))\n  data.pred.new.vals <- data.pred.new[\n    sel.ix, list(PredAvg = mean(Pred)), by=col.by][\n    order(Year)]\n  for (ix in 0:1) {\n    data.pred.new.vals[Year %% 2 == ix, PredAvg := PredAvg/max(PredAvg)]\n  }\n  data.pred.new.vals <- merge(data.pred.new.vals, data.mult, by=col.by)\n  data.pred.new.vals[, Factor := PredRatio/PredAvg]\n  data.pred.new <- merge(data.pred.new, data.pred.new.vals, by=col.by)\n  data.pred.new[,Pred:=Pred*Factor]\n  data.pred.new <- data.pred.new[order(Id)]\n  data.pred.new <- data.pred.new[, colnames(data.pred), with=F]\n  data.pred.new\n}\n\n\n##############################################################\n## likelihood - needs fix\n##############################################################\n#   fn.calc.likelihood <- function(data.all, by, tr.idx, test.idx, smooth=10) {\n#     tr.years <- sort(unique(data.all$Year[tr.idx]))\n#     test.years <- sort(unique(data.all$Year[test.idx]))\n#     gavg <- mean(data.all$WnvPresent[tr.idx])\n#     data.calc.year <- NULL\n#     for (cur.year in c(tr.years, test.years)) {\n#       data.calc.year.cur <- data.all[tr.idx,][Year != cur.year]\n#       data.calc.year.cur <- data.calc.year.cur[\n#         ,list(WnvPresent=sum(WnvPresent), n=.N),by=by]\n#       data.calc.year.cur[, Val := (WnvPresent + smooth*gavg)/(n+smooth)]\n#       data.calc.year.cur[, Year := cur.year]\n#       data.calc.year.cur <- data.calc.year.cur[, c(\"Year\", by, \"Val\"), with=F]\n#       data.calc.year <- rbind(data.calc.year, data.calc.year.cur)\n#     }\n#     setkeyv(data.calc.year, c(\"Year\", by))\n#     data.all.key <- data.all[c(tr.idx, test.idx), c(\"Year\", by), with=F]\n#     prob.val <- rep(NA_real_, nrow(data.all))\n#     prova.val.sel <- data.calc.year[data.all.key]$Val\n#     #prova.val.sel[is.na(prova.val.sel)] <- gavg\n#     prob.val[c(tr.idx, test.idx)] <- prova.val.sel\n#     prob.val\n#   }\n#   \n#   fn.add.prob <- function(data.all, col.nam, ...) {\n#     col.prob <- paste0(paste(col.nam, collapse=\"\"), \"Prob\")\n#     data.all[, col.prob := fn.calc.likelihood(\n#       data.all.cur, by=col.nam, tr.idx=data.fold$tr.idx.in,\n#       test.idx = data.fold$test.idx.in, ...), with=F]\n#     data.all[is.na(get(col.prob)), col.prob := -1000, with=F]\n#   }\n#   fn.add.prob(\"Trap\")\n\n##############################################################\n## add date fields\n##############################################################\nfn.add.date.fields <- function(data.all) {\n  \n  if (!\"Date\" %in% colnames(data.all)) {\n    data.all <- merge(\n      data.all,\n      data.all.out[, list(Id, Date)],\n      by=\"Id\"\n    )\n  }\n  data.all[, Year := as.numeric(format(as.Date(Date, format=\"%Y-%m-%d\"), \n                                            format = \"%Y\"))]\n  data.all[, Month := as.numeric(format(as.Date(Date, format=\"%Y-%m-%d\"), \n                                             format = \"%m\"))]\n  data.all[, WeekYear := as.numeric(format(as.Date(Date, format=\"%Y-%m-%d\"), \n                                                format = \"%V\"))]\n  data.all[, DayYear := as.numeric(format(as.Date(Date, format=\"%Y-%m-%d\"), \n                                               format = \"%j\"))]\n  invisible(data.all)\n}\n\n##############################################################\n## moving average\n##############################################################\nfn.ma <- function(x, n=1) {\n    sapply(1:length(x), function (ix) {\n    ix <- seq.int(ix, ix-n+1)\n    ix <- ix[ix > 0]\n    mean(x[ix], na.rm=T)\n  })  \n}\n\n##############################################################\n## geometric average\n##############################################################\nfn.gm.mean = function(x, na.rm=TRUE, zero.propagate = FALSE){\n  if(any(x < 0, na.rm = TRUE)){\n    return(NaN)\n  }\n  if(zero.propagate){\n    if(any(x == 0, na.rm = TRUE)){\n      return(0)\n    }\n    exp(mean(log(x), na.rm = na.rm))\n  } else {\n    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))\n  }\n}\n\n##############################################################\n## geometric average\n##############################################################\nfn.gma <- function(x, n=1) {\n  sapply(1:length(x), function (ix) {\n    ix <- seq.int(ix, ix-n+1)\n    ix <- ix[ix > 0 & ix <= length(x)]\n    fn.gm.mean(x[ix], na.rm=T)\n  })    \n}\n\n##############################################################\n## weather plot function\n##############################################################\nfn.plot.weather <- function(feat) {\n  data.weather.cur <- fn.add.date.fields(copy(data.weather))\n  par(mfrow=c(4,2))\n  for (year in 2007:2014) {\n    data.plot <- data.weather.cur[Year == year]\n    model.loess <- loess(\n      as.formula(paste(feat, \"DayYear\", sep=\"~\")), \n      data=data.plot, span = 0.4)\n    pred <- predict(model.loess, data.plot)\n    plot(y=pred, x=data.plot$DayYear,\n         type=\"l\", ylab=feat, xlab=\"Day\",\n         ylim=c(min(data.weather.cur[[feat]], na.rm=T), \n                max(data.weather.cur[[feat]], na.rm=T)), \n         xlim=c(min(data.weather.cur$DayYear, na.rm=T), \n                max(data.weather.cur$DayYear, na.rm=T)),\n         main=paste(year),\n         col = \"blue\")\n    model.loess <- loess(\n      as.formula(paste(feat, \"DayYear\", sep=\"~\")), \n      data=data.plot, span = 0.1)\n    pred <- predict(model.loess, data.plot)\n    lines(y=pred, x=data.plot$DayYear, col=\"red\")\n    lines(y=data.plot[[feat]], x=data.plot$DayYear)\n  }\n}\n\n##############################################################\n## year infection plot function\n##############################################################\nfn.plot.year.evolution <- function(data.pred.names) {\n  data.out.cur <- fn.add.date.fields(copy(data.all.out))\n  for (data.pred.name in data.pred.names)  {\n    data.pred <- copy(get(data.pred.name))[Pred > 0]\n    setnames(data.pred, \"Pred\", data.pred.name)\n    data.out.cur <- merge(data.out.cur, data.pred, by=\"Id\")\n  }\n\n  par(mfrow=c(4,2))\n  for (year in 2007:2014) {\n    data.plot <- data.out.cur[\n      Year == year,\n      list(\n        WnvPresent = as.numeric(sum(WnvPresent, na.rm=T)),\n        NumMosquitos = as.numeric(sum(NumMosquitos, na.rm=T)),\n        InfectRate = as.numeric(sum(NumMosquitos[WnvPresent %in% 1], na.rm=T)/\n                                  sum(NumMosquitos, na.rm=T))\n      ),\n      by=c(\"WeekYear\")]\n    data.plot.mult <- data.mult.weekly.01[Year == year]\n    data.plot.mult[, PredRatio := PredRatio/max(PredRatio)]\n    data.plot <- merge(data.plot, data.plot.mult,\n                       all.x=T, by=c(\"WeekYear\"))\n    data.plot[is.na(PredRatio), PredRatio := 0]\n    data.plot[!is.na(WnvPresent), \n              WnvPresent := WnvPresent/max(WnvPresent)]\n    data.plot[!is.na(NumMosquitos), \n              NumMosquitos := NumMosquitos/max(NumMosquitos)]\n    data.plot[!is.na(InfectRate), \n              InfectRate := InfectRate/max(InfectRate)]\n    for (data.pred.name in data.pred.names)  {\n      data.pred <- copy(data.out.cur)[Year == year]\n      setnames(data.pred, data.pred.name, \"Pred\")\n      data.plot <- merge(data.plot, \n                         data.pred[,list(Pred = mean(Pred)),by=\"WeekYear\"],\n                         by=\"WeekYear\")\n      data.plot[, Pred := Pred/max(Pred)]\n      setnames(data.plot, \"Pred\", data.pred.name)\n    } \n    data.plot <- data.plot[order(WeekYear)]\n\n    plot(y=data.plot[[data.pred.names[1]]], x=data.plot$WeekYear,\n         type=\"l\", ylab=\"Norm values\", xlab=\"Week\",\n         ylim=c(0, 1), \n         xlim=c(min(data.out.cur$WeekYear-5, na.rm=T), \n                max(data.out.cur$WeekYear, na.rm=T)),\n         main=paste(year),\n         lty=3,\n         col = \"blue\")\n    legends <- list(txt=data.pred.names[1],\n                    col=\"blue\",\n                    lty=3)\n    cols.sel <- c(\"brown\", \"blueviolet\", \"bisque3\", \"orange3\", \"darkgreen\",\n                  \"gold\", \"darkviolet\", \"deeppink\", \"gray\")\n    for (ix in 2:length(data.pred.names))  {\n      lines(y=data.plot[[data.pred.names[ix]]], \n            x=data.plot$WeekYear, col=cols.sel[ix-1],\n            lty=3)\n      legends$txt <- c(legends$txt, data.pred.names[ix])\n      legends$col <- c(legends$col, cols.sel[ix-1])\n      legends$lty <- c(legends$lty, 3)\n    }\n    if (any(!is.na(data.plot$WnvPresent))) {\n      lines(y=data.plot$WnvPresent, x=data.plot$WeekYear, col=\"green\")\n      legends$txt <- c(legends$txt, \"Actual\")\n      legends$col <- c(legends$col, \"green\")\n      legends$lty <- c(legends$lty, 1)\n      \n    }\n    if (any(!is.na(data.plot$WnvPresent))) {\n      lines(y=data.plot$NumMosquitos, x=data.plot$WeekYear, col=\"black\", lty=2)\n      legends$txt <- c(legends$txt, \"Num. Mosq.\")\n      legends$col <- c(legends$col, \"black\")\n      legends$lty <- c(legends$lty, 2)\n    }\n    if (any(!is.na(data.plot$PredRatio))) {\n      lines(y=data.plot$PredRatio, x=data.plot$WeekYear, col=\"red\", lty=2)\n      legends$txt <- c(legends$txt, \"Pred Ratio\")\n      legends$col <- c(legends$col, \"red\")\n      legends$lty <- c(legends$lty, 2)\n    }\n    legend(\"topleft\", legend=legends$txt, col=legends$col, lty=legends$lty,\n           cex=0.5)\n  }\n}\n\n#############################################################\n# fixing zero value predictions\n#############################################################\nfn.fix.zero.pred <- function(data.pred) {\n  data.pred.cur <- merge(data.pred, \n                         data.all.trap[, list(Id, Species)], \n                         by=\"Id\")\n  data.pred.cur[Species == \"CULEX ZOTHER\", Pred := 0]\n  data.pred.cur[, Species := NULL]\n  data.pred.cur\n}\n\n#############################################################\n# coordinates distances\n#############################################################\nfn.dist.coord <- function(tlat, tlong, slat, slong) {\n  library(\"geosphere\")\n  n <- length(tlat)\n  if (length(slat) == 1) {\n    slat <- rep(slat, n)\n    slong <- rep(slong, n)\n  }\n  fn.harv.apply <- function(ix) {\n    distHaversine(c(tlat[ix],tlong[ix]),c(slat[ix],slong[ix]))/1000\n  }\n  mapply(fn.harv.apply,ix=1:n)\n}\n\n# #############################################################\n# # smoothing predictions - linear regression\n# #############################################################\n# fn.smooth.lm.pred <- function(data.pred, wnd.n=1, wnd.days=15) {\n#   \n#   data.pred.cur <- merge(fn.apply.mult(data.pred),\n#                          data.all.out, by=\"Id\")\n#   data.pred.cur <- merge(data.pred.cur,\n#                          data.all.trap[, list(Id, Species, TrapFixed)], by=\"Id\")\n#   data.pred.cur <- fn.add.date.fields(data.pred.cur)\n#   data.pred.cur.ids <- data.pred.cur[, list(Id, Date, TrapFixed, Species)]\n#   \n#   data.pred.key <- c(\"Date\", \"TrapFixed\", \"Species\")\n#   data.pred.cur <- data.pred.cur[\n#     ,list(\n#       WnvPresent = as.numeric(mean(WnvPresent)),\n#       Pred = mean(Pred),\n#       Year = unique(Year)\n#     )\n#     ,by=data.pred.key\n#     ]\n#   setkeyv(data.pred.cur, data.pred.key)\n#   data.pred.dates <- as.Date(data.pred.cur$Date, format=\"%Y-%m-%d\")\n#   \n#   data.wnd.mat.prev <- Matrix(data=NA_real_, \n#                      nrow=nrow(data.pred.cur), \n#                      ncol=wnd.days)\n#   data.wnd.mat.next <- Matrix(data=NA_real_, \n#                      nrow=nrow(data.pred.cur), \n#                      ncol=wnd.days)\n#   for (ix in 1:wnd.days) {\n#     pred.key.dt <- data.pred.cur[,data.pred.key,with=F]\n#     \n#     pred.key.dt[, Date := format(data.pred.dates-ix, format = \"%Y-%m-%d\")]\n#     data.wnd.mat.prev[,ix] <- data.pred.cur[pred.key.dt]$Pred\n#     \n#     pred.key.dt[, Date := format(data.pred.dates+ix, format = \"%Y-%m-%d\")]\n#     data.wnd.mat.next[,ix] <- data.pred.cur[pred.key.dt]$Pred\n#   }\n# \n#   pred.fill.prev <- data.pred.cur$Pred\n#   pred.fill.next <- data.pred.cur$Pred\n#   for (ix in 1:wnd.n) {\n#     fn.calc.wnd <- function(x) x[c(which(!is.na(x)), rep(1,wnd.n))][ix]\n#     col.nam <- paste0(\"PredPrev\", ix)\n#     data.pred.cur[\n#     , col.nam := apply(data.wnd.mat.prev, 1, fn.calc.wnd) , with=F]\n#     ix.na <- is.na(data.pred.cur[[col.nam]])\n#     data.pred.cur[ix.na, col.nam:= pred.fill.prev[ix.na], with=F]\n#     pred.fill.prev <- data.pred.cur[[col.nam]]\n#     col.nam <- paste0(\"PredNext\", ix)\n#     data.pred.cur[\n#     , col.nam := apply(data.wnd.mat.next, 1, fn.calc.wnd) , with=F]\n#     ix.na <- is.na(data.pred.cur[[col.nam]])\n#     data.pred.cur[ix.na, col.nam:= pred.fill.next[ix.na], with=F]\n#     pred.fill.next <- data.pred.cur[[col.nam]]\n#   }\n#   \n#   cols.feat <- c(\"Pred\", \n#                  paste0(\"PredPrev\", 1:wnd.n), \n#                  paste0(\"PredNext\", 1:wnd.n))\n#   data.pred.cur.sum <- rowSums(data.pred.cur[,cols.feat,with=F])\n#   data.pred.cur.unique <- apply(data.pred.cur[,cols.feat,with=F], 1,\n#                                 function (x) length(unique(x)))\n#   \n#   tr.years <- seq(2007, 2013, 2)\n#   test.years <- seq(2008, 2014, 2)\n#   \n#   pred.smooth <- data.pred.cur[, data.pred.key, with=F]\n#   pred.smooth[, Pred := 0.0]\n#   \n#   fn.nnls <- function(data.tr, data.test, do.print=F) {\n#     library(nnls)\n#     model.smooth <- nnls(as.matrix(data.tr[,cols.feat,with=F]), \n#                       data.tr$WnvPresent)\n#     if (do.print) {\n#       print(model.smooth)\n#     }\n#     model.smooth.coef <- coef(model.smooth)\n#     model.smooth.coef <- model.smooth.coef/sum(model.smooth.coef)\n#     as.vector(model.smooth.coef%*%t(as.matrix(data.test[,cols.feat,with=F])))\n#   }\n#   for (yr in tr.years) {\n#     ix.tr <- which(with(data.pred.cur, Year != yr \n#                         & !is.na(WnvPresent) \n#                         & data.pred.cur.sum != 0\n#                         & data.pred.cur.unique > 1))\n#     ix.test <- which(with(data.pred.cur, Year == yr))\n#     pred.smooth[ix.test, \"Pred\"] <- fn.nnls(data.pred.cur[ix.tr],\n#                                             data.pred.cur[ix.test])\n#   }\n#   ix.tr <- which(with(data.pred.cur, Year %in% tr.years \n#                       & !is.na(WnvPresent) \n#                       & data.pred.cur.sum != 0\n#                       & data.pred.cur.unique > 1))\n#   ix.test <- which(with(data.pred.cur, Year %in% test.years))\n#   pred.smooth[ix.test, \"Pred\"] <- fn.nnls(data.pred.cur[ix.tr],\n#                                           data.pred.cur[ix.test],\n#                                           do.print=T)\n#   pred.smooth <- merge(data.pred.cur.ids, pred.smooth, all.x=T,\n#                        by=data.pred.key)[order(Id), list(Id, Pred)]\n#   \n#   pred.smooth\n# }\n\n#############################################################\n# smoothing predictions - moving avg\n#############################################################\nfn.smooth.time.ma.pred <- function(data.pred, n.prev, n.nxt, \n                                   pred.w, ma.func) {\n  \n  \n  \n  data.pred.cur <- merge(data.pred,\n                         data.all.out[, list(Id, Date)], by=\"Id\")\n  data.pred.cur <- merge(data.pred.cur,\n                         data.all.trap[, list(Id, Species, TrapFixed)], by=\"Id\")\n  data.pred.cur <- fn.add.date.fields(data.pred.cur)\n  data.pred.cur.ids <- data.pred.cur[, list(Id, Date, TrapFixed, Species)]\n  \n  data.pred.key <- c(\"Date\", \"TrapFixed\", \"Species\")\n  data.pred.cur <- data.pred.cur[order(Date)][\n    ,list(\n      Pred = mean(Pred),\n      DayYear = unique(DayYear),\n      Year = unique(Year)\n    )\n    ,by=data.pred.key\n    ][order(Date)]\n  \n  fn.ma.smooth <- function(pred) {\n    if (length(unique(pred)) == 1) {\n      return (pred)\n    }\n    n.nxt.ma <- n.nxt+1\n    n.prev.ma <- n.prev+1\n    return ( (\n      ma.func(pred, n=n.prev.ma)*n.prev.ma \n      + rev(ma.func(rev(pred), n=n.nxt.ma))*n.nxt.ma \n      - 2*pred\n      + pred.w*pred\n      )/(n.nxt.ma+n.prev.ma+pred.w-2) )\n  }\n  \n  data.pred.cur <- data.pred.cur[\n    ,list(\n      Date = Date,\n      Pred = fn.ma.smooth(Pred)\n    ), by=c(\"Year\", \"TrapFixed\", \"Species\")]\n\n  pred.smooth <- merge(data.pred.cur.ids, data.pred.cur, all.x=T,\n                       by=data.pred.key)[order(Id), list(Id, Pred)]\n  \n  pred.smooth\n}\n\n#############################################################\n# smoothing predictions by location - linear regression\n#############################################################\nfn.smooth.loc.ma.pred <- function(data.pred, n, pred.w, ma.func=mean) {\n  \n  data.pred.cur <- merge(data.pred,\n                         data.all.out[, list(Id, WnvPresent, Date)], by=\"Id\")\n  data.pred.cur <- merge(data.pred.cur,\n                         data.all.trap[, list(Id, Species, TrapFixed)], by=\"Id\")\n  data.pred.cur <- fn.add.date.fields(data.pred.cur)\n  data.pred.cur.ids <- data.pred.cur[, list(Id, Date, TrapFixed, Species)]\n  \n  data.pred.key <- c(\"Date\", \"TrapFixed\", \"Species\")\n  data.pred.cur <- data.pred.cur[\n    ,list(\n      WnvPresent = as.numeric(mean(WnvPresent)),\n      Pred = mean(Pred),\n      Year = unique(Year)\n    )\n    ,by=data.pred.key\n    ]\n  setkeyv(data.pred.cur, data.pred.key)\n  \n  data.trap.dist.near <- data.trap.dist[\n    ,list(\n      TrapFixedNear = head(TrapFixed2[order(Tdist)], n=n)\n    ), by=\"TrapFixed1\"]\n  \n  for (trap.nam in sort(unique(data.pred.cur$TrapFixed))) {\n    trap.near <- data.trap.dist.near[J(trap.nam)]$TrapFixedNear\n    trap.ix <- which(data.pred.cur$TrapFixed==trap.nam)\n    for (ix in 1:n) {\n      pred.key.dt <- data.pred.cur[trap.ix,data.pred.key,with=F]\n      pred.key.dt[, TrapFixed := trap.near[ix]]\n      pred.vals <- data.pred.cur[pred.key.dt]$Pred\n      data.pred.cur[trap.ix, paste0(\"PredTN\", ix) := pred.vals, with=F]\n    }\n  }\n  \n  cols.feat <- paste0(\"PredTN\", 1:n)\n  fn.ma.smooth <- function(pred) {\n    return ( ma.func( c(rep(pred[1], pred.w), pred[-1]) ) )\n  }\n  \n  cols.feat <- c(\"Pred\", cols.feat)\n  pred.smooth <- data.pred.cur[, c(data.pred.key, cols.feat), with=F]\n  pred.smooth[\n    , Pred := apply(data.pred.cur[, cols.feat, with=F], 1, fn.ma.smooth)]\n  \n  pred.smooth <- pred.smooth[, c(data.pred.key, \"Pred\"), with=F]\n  pred.smooth <- merge(data.pred.cur.ids, pred.smooth, all.x=T,\n                       by=data.pred.key)[order(Id), list(Id, Pred)]\n  pred.smooth\n}\n\n#############################################################\n# time and location smoothing\n#############################################################\nfn.smooth.pred <- function(data.pred, trap.n=4, \n                           time.n.prev=3, time.n.nxt=time.n.prev,\n                           pred.w=4, time.ma.fn=fn.ma,\n                           data.mult = data.mult.01) {\n  \n  data.pred.cur <- copy(data.pred)\n  data.pred.cur <- fn.smooth.loc.ma.pred(data.pred.cur, n=trap.n,\n                                         pred.w=pred.w)\n  data.pred.cur <- fn.smooth.time.ma.pred(data.pred.cur, \n                                          n.prev=time.n.prev, n.nxt=time.n.nxt, \n                                          pred.w=pred.w,\n                                          ma.func=time.ma.fn)\n  if (!is.null(data.mult)) {\n    data.pred.cur <- fn.apply.mult(data.pred.cur, data.mult = data.mult)\n  }\n  data.pred.cur\n}\n\n#############################################################\n# write rgf files\n#############################################################\nfn.rgf.write <- function(data, file) {\n  write.table(\n    data,\n    file=file,\n    row.names = F, quote = F, na = \"\", sep = \" \",\n    append = F, col.names = F\n  )\n}\n\n#############################################################\n# rgf file names\n#############################################################\nfn.rgf.tr.file <- function(data.fold, suffix) {\n  paste0(data.fold$writedir, \"/\", data.fold$name,\"_tr.\", suffix)\n}\n\nfn.rgf.test.file <- function(data.fold, suffix) {\n  paste0(data.fold$writedir, \"/\", data.fold$name,\"_test.\", suffix)\n}\n\n#############################################################\n# rgf train config file\n#############################################################\nfn.rgf.write.cfg <- function(data.fold, params) {\n  # train\n  lines <- c(\n    paste0(\"train_x_fn=\", data.fold$tr.x.file),\n    paste0(\"train_y_fn=\", data.fold$tr.y.file),\n    paste0(\"model_fn_prefix=\", data.fold$tr.model.file),\n    paste0(\"test_x_fn=\", data.fold$test.x.file),\n    #paste0(\"prediction_fn=\", data.fold$test.pred.file),\n    paste0(\"SaveLastModelOnly\")\n  )\n  for (nam in names(params)) {\n    line <- nam\n    if (!is.character(params[[nam]]) ||  params[[nam]] != \"\") {\n      line = paste(line,params[[nam]], sep=\"=\")\n    }\n    lines <- c(lines, line)\n  }\n  writeLines(lines, con = paste0(data.fold$tr.cfg.file, \".inp\"))\n}\n\n#############################################################\n# convert log odds to probabilities\n#############################################################\nfn.from.logit <- function(x) {\n  1/(1+exp(-x))\n}\n\nfn.to.logit <- function(x) {\n  (x-0.5)*2\n}\n\n#############################################################\n# nnls regression\n#############################################################\nfn.nnls.train <- function(x, y, intercept=T, coef.norm=F) {\n  library(nnls)\n  coef.names <- colnames(x)\n  x <- as.matrix(x)\n  if (intercept) {\n    x <- cbind(Matrix(data=1, nrow=nrow(x)), x)\n    coef.names <- c(\"Intercept\", coef.names)\n  }\n  model <- nnls(x, y)\n  model.coefs <- coef(model)\n  if (coef.norm) {\n    model.coefs <- model.coefs/sum(model.coefs)\n  }\n  model <- (list(model=model, intercept=intercept, \n               coef.names=coef.names, model.coefs=model.coefs))\n  names(model$model.coefs) <- coef.names\n  model\n}\n\nfn.nnls.predict <- function(model, x) {\n  library(nnls)\n  x <- as.matrix(x)\n  if (model$intercept) {\n    x <- cbind(Matrix(data=1, nrow=nrow(x)), x)\n  }\n  as.vector(model$model.coefs%*%t(x))\n}\n\n\n#############################################################\n# opt auc regression\n#############################################################\nfn.opt.pred <- function(pars, x) {\n  if (\"par\" %in% names(pars)) {\n   pars <- pars$par \n  }\n\tpars.m <- matrix(rep(pars,each=nrow(x)),nrow=nrow(x))\n\trowSums(data.x*pars.m)\n}\n\nfn.opt <- function(x, y) {\n  return (function(pars) {\n    #-auc(y, fn.opt.pred(pars, c))\n    -fn_opt_auc(y, x, pars)\n  })\n}\n\nfn.opt.run <- function(x, y, pars=rep(1/ncol(x),ncol(x)), norm.pars=T) {\n  res <- optim(pars, fn.opt(x, y), \n               control = list(trace = T))\n  if (norm.pars) {\n    res$par <- res$par/sum(res$par)\n  }\n  res\n}\n",
    "created" : 1434916010648.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3787169091",
    "id" : "44989849",
    "lastKnownWriteTime" : 1434821730,
    "path" : "~/Dropbox/WestNile2015/final_code/west-niles-virus-r/fn.base.R",
    "project_path" : "fn.base.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}